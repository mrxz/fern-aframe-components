!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(require("aframe"),require("three"),require("@webxr-input-profiles/motion-controllers")):"function"==typeof define&&define.amd?define(["aframe","three","@webxr-input-profiles/motion-controllers"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).AFRAME,e.THREE,e.motionControllers)}(this,(function(e,t,n){"use strict";function o(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var o=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,o.get?o:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var i=o(e),r=o(t);const s=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];i.registerComponent("motion-controller-model",{schema:{hand:{type:"string",oneOf:["left","right"],default:"left"},overrideMaterial:{type:"string",oneOf:["none","phong","occluder"],default:"phong"},overrideHandMaterial:{type:"string",oneOf:["none","phong","occluder","hologram"],default:"hologram"},buttonTouchColor:{type:"color",default:"#8AB"},buttonPressColor:{type:"color",default:"#2DF"}},__fields:{},init:function(){this.motionControllerSystem=this.el.sceneEl.systems["motion-controller"],this.componentMeshes=new Map,this.handJoints=new Array(25);const e=new i.THREE.GLTFLoader;this.el.sceneEl.addEventListener("motion-controller-change",(t=>{const n=this.motionControllerSystem[this.data.hand];if(this.inputSourceRecord=n,n&&n.motionController)e.load(n.motionController.assetUrl,(e=>{if(this.motionController!==n.motionController)return;this.el.setObject3D("mesh",e.scene);const t="generic-hand"===this.motionController?.id;e.scene.traverse((e=>{if(!e.isMesh)return;if(t&&"SkinnedMesh"===e.type){const t=e,n=t.skeleton.bones;for(const e of n){const t=s.indexOf(e.name);-1!==t&&(this.handJoints[t]=e)}t.frustumCulled=!1}const n=e;switch(t?this.data.overrideHandMaterial:this.data.overrideMaterial){case"phong":n.material=(o=n.material,new r.MeshPhongMaterial({color:o.color.clone(),map:o.map,side:o.side}));break;case"occluder":n.material=function(e){return new r.MeshBasicMaterial({colorWrite:!1,side:e.side})}(n.material);break;case"hologram":n.material=function(e){const t=new r.ShaderMaterial({side:e.side,opacity:.4,transparent:!0,vertexShader:"\n            #include <common>\n            #include <normal_pars_vertex>\n            #include <skinning_pars_vertex>\n\n            uniform float outline;\n\n            varying vec3 vObjectPosition;\n            varying vec3 vWorldPosition;\n\n            void main() {\n                #include <beginnormal_vertex>\n                #include <skinbase_vertex>\n\t            #include <skinnormal_vertex>\n                #include <defaultnormal_vertex>\n                #include <normal_vertex>\n\n                #include <begin_vertex>\n                if(outline > 0.0) {\n                    transformed += normal*0.001;\n                }\n                #include <skinning_vertex>\n                #include <project_vertex>\n\n                vObjectPosition = position;\n\n                vWorldPosition = mvPosition.xyz;\n            }\n        ",fragmentShader:"\n            #include <common>\n            #include <dithering_pars_fragment>\n            #include <normal_pars_fragment>\n\n            uniform float outline;\n\n            varying vec3 vObjectPosition;\n            varying vec3 vWorldPosition;\n\n            void main() {\n\n                if(outline > 0.0) {\n                    float alpha = 0.5 * min((-vObjectPosition.y + 0.09)/0.15, 1.0);\n                    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);\n                } else {\n                    vec3 toCamera = normalize(cameraPosition - vWorldPosition);\n                    float factor = pow(1.0 - dot(toCamera, vNormal), 10.0);\n\n                    float alpha = 0.5 * min((-vObjectPosition.y + 0.06)/0.15, 1.0);\n                    vec3 color = mix(vec3(0.0), vec3(0.8, 0.8, 1.0), factor);\n\n                    gl_FragColor = vec4(color, alpha);\n                }\n\n                #include <tonemapping_fragment>\n                #include <colorspace_fragment>\n            }\n        ",uniforms:{outline:{value:1}}});return t.onBeforeRender=(e,n,o,i,s,a)=>{t.colorWrite=!1,e.renderBufferDirect(o,n,i,t,s,a),t.colorWrite=!0,t.side=r.BackSide,t.uniforms.outline.value=1,t.uniforms.outline.needsUpdate=!0,t.needsUpdate=!0,e.renderBufferDirect(o,n,i,t,s,a),t.side=r.FrontSide,t.uniforms.outline.value=0,t.uniforms.outline.needsUpdate=!0,t.needsUpdate=!0},t}(n.material)}var o})),this.componentMeshes.clear(),Object.values(this.motionController.components).forEach((t=>{const n=[];this.componentMeshes.set(t.id,n),Object.values(t.visualResponses).forEach((t=>{const o=e.scene.getObjectByName(t.valueNodeName),i=t.minNodeName?e.scene.getObjectByName(t.minNodeName):void 0,r=t.maxNodeName?e.scene.getObjectByName(t.maxNodeName):void 0;if(o){if(o.traverse((e=>{if("Mesh"===e.type){const t=e,o=t.material.color.clone();n.push({mesh:t,originalColor:o})}})),t.valueNode=o,"transform"===t.valueNodeProperty){if(!i||!r)return console.error("Missing value node in model for visualResponse: ",t.componentProperty),void(t.valueNode=void 0);t.minNode=i,t.maxNode=r}}else console.error("Missing value node in model for visualResponse: ",t.componentProperty)}))}))})),this.motionController=n.motionController;else{this.el.getObject3D("mesh")&&this.el.removeObject3D("mesh");for(let e=0;e<25;e++)this.handJoints[e]=void 0;this.motionController=null}}))},remove:function(){},tick:function(){if(this.motionController&&this.el.getObject3D("mesh")){if(this.inputSourceRecord?.jointState)for(let e=0;e<25;e++){const t=this.handJoints[e];t.matrix.fromArray(this.inputSourceRecord.jointState.poses,16*e),t.matrix.decompose(t.position,t.quaternion,t.scale)}for(const e in this.motionController.components){const t=this.motionController.components[e];Object.values(t.visualResponses).forEach((e=>{const{valueNode:t,minNode:n,maxNode:o,value:i,valueNodeProperty:r}=e;t&&("visibility"===r?t.visible=i:"transform"===r&&(t.quaternion.slerpQuaternions(n.quaternion,o.quaternion,i),t.position.lerpVectors(n.position,o.position,i)))}));let n=null;"touched"===t.values.state?n=this.data.buttonTouchColor:"pressed"===t.values.state&&(n=this.data.buttonPressColor),this.componentMeshes.get(e)?.forEach((e=>{e.mesh.material.color.set(n||e.originalColor)}))}}}}),i.registerComponent("motion-controller-space",{schema:{hand:{type:"string",oneOf:["left","right"],default:"left"},space:{type:"string",oneOf:["gripSpace","targetRaySpace"],default:"targetRaySpace"}},__fields:{},init:function(){this.motionControllerSystem=this.el.sceneEl.systems["motion-controller"],this.el.sceneEl.addEventListener("motion-controller-change",(e=>{const t=this.motionControllerSystem[this.data.hand];this.inputSource=t?.xrInputSource}))},tick:function(){const e=this.el.sceneEl.frame,t=this.el.sceneEl.renderer.xr.getReferenceSpace?.();if(!this.inputSource||!e||!t)return;const n=this.inputSource[this.data.space];if(!n)return;const o=e.getPose(n,t);o&&(this.el.object3D.matrix.fromArray(o.transform.matrix),this.el.object3D.matrix.decompose(this.el.object3D.position,this.el.object3D.quaternion,this.el.object3D.scale))}});const a="generic-hand";i.registerSystem("motion-controller",{schema:{profilesUri:{type:"string",default:"https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets/dist/profiles"},enableHandTracking:{type:"boolean",default:!0},enableHands:{type:"boolean",default:!0}},__fields:{},init:function(){this.inputSources=[],this.left=null,this.right=null,this.data.enableHands&&this.data.enableHandTracking&&this.sceneEl.setAttribute("webxr",{optionalFeatures:["hand-tracking"]});const e=e=>{e.removed.forEach((e=>{const t=this.inputSources.findIndex((t=>t.xrInputSource===e));if(-1!==t){const[e]=this.inputSources.splice(t,1);this.left===e&&(this.left=null),this.right===e&&(this.right=null)}})),e.added.forEach((async e=>{if(!this.data.enableHands&&e.profiles.includes(a))return;const t={xrInputSource:e,componentState:{}};this.inputSources.push(t),"left"===e.handedness?this.left=t:"right"===e.handedness&&(this.right=t);const{profile:o,assetPath:i}=await n.fetchProfile(e,this.data.profilesUri);t.motionController=new n.MotionController(e,o,i);for(const e in t.motionController.components){const n=t.motionController.components[e];t.componentState[e]={...n.values}}t.motionController.id===a&&(t.jointState={poses:new Float32Array(400),radii:new Float32Array(25)}),this.sceneEl.emit("motion-controller-change")})),this.sceneEl.emit("motion-controller-change")};this.el.sceneEl.addEventListener("enter-vr",(t=>{this.xrSession=this.el.sceneEl.xrSession,this.xrSession&&this.xrSession.addEventListener("inputsourceschange",e)})),this.el.sceneEl.addEventListener("exit-vr",(t=>{this.xrSession&&(this.xrSession.removeEventListener("inputsourceschange",e),this.xrSession=null,this.inputSources.splice(0,this.inputSources.length),this.left=null,this.right=null,this.sceneEl.emit("motion-controller-change"))}))},tick:function(){this.inputSources.forEach((e=>{if(!e.motionController)return;e.motionController.updateFromGamepad(),e.motionController.id===a&&this.updateHandJoints(e);const t=this.left===e?"left":this.right===e?"right":void 0;for(const n in e.motionController.components){const o=e.motionController?.components[n],i=e.componentState[n],r={inputSource:e.xrInputSource,motionController:e.motionController,hand:t,button:n,buttonState:o.values},s=i.state;i.state=o.values.state;const a=i.xAxis;i.xAxis=o.values.xAxis;const l=i.yAxis;i.yAxis=o.values.yAxis,o.values.state!==s&&("touched"===s?this.el.emit("touchend",r):"pressed"===s&&this.el.emit("buttonup",r),"touched"===o.values.state?this.el.emit("touchstart",r):"pressed"===o.values.state&&this.el.emit("buttondown",r)),"thumbstick"!==o.type&&"touchpad"!==o.type||a===o.values.xAxis&&l===o.values.yAxis||this.el.emit("axismove",r)}}))},updateHandJoints:function(e){const t=this.el.sceneEl.frame;if(!t)return;const n=e.xrInputSource.hand;n&&(t.fillPoses(n.values(),e.xrInputSource.gripSpace,e.jointState.poses),t.fillJointRadii(n.values(),e.jointState.radii))}})}));
