!function(t){"function"==typeof define&&define.amd?define(t):t()}((function(){"use strict";AFRAME.registerSystem("portal",{schema:{},portals:[],init:function(){const t=this.sceneEl.renderer;t.autoClear=!1,t.info.autoReset=!1;const e=function(){},r=new THREE.Mesh;r.frustumCulled=!1,r.material.transparent=!0,r.renderOrder=Number.MAX_VALUE,this.sentinel=r,this.sceneEl.object3D.add(this.sentinel),r.onAfterRender=(t,i,s)=>{if(t.xr.isPresenting){const e=t.xr.getCamera().cameras;if(s!=e[e.length-1])return}r.visible=!1,this.portals.forEach((t=>t.setInactive()));const n=i.onAfterRender;i.onAfterRender=e,this.portals.forEach((e=>e.render(t,i,s))),this.portals.forEach((t=>t.setActive())),r.visible=!0,i.onAfterRender=n}},tick:function(){const t=this.sceneEl.object3D;t.children[t.children.length-1]!==this.sentinel&&t.add(this.sentinel),this.sceneEl.renderer.info.reset()},registerPortal:function(t){this.portals.push(t),t.setPortalId(this.portals.length)},unregisterPortal:function(t){const e=this.portals.indexOf(t);-1!==e&&(this.portals.splice(e,1),this.portals.forEach(((t,e)=>t.setPortalId(e+1))))}});const t={schema:{layers:{type:"array",default:[0]}},init:function(){const t=this.el.getObject3D("mesh");this.surfaceMaterial=t.material;const e=this.surfaceMaterial;e.transparent=!0,e.colorWrite=!1,e.depthWrite=!0,e.stencilWrite=!0,e.depthFunc=THREE.LessEqualDepth,e.stencilFunc=THREE.AlwaysStencilFunc,e.stencilZPass=THREE.ReplaceStencilOp,e.stencilZFail=THREE.KeepStencilOp,this.el.sceneEl.systems.portal.registerPortal(this),e.stencilRef=this.portalId,this.insideFrustum=!1,t.onBeforeRender=()=>{this.insideFrustum=!0},this.layers=new THREE.Layers,this.layers.disableAll(),this.tempCamera=new THREE.PerspectiveCamera,this.tempCameras=[new THREE.PerspectiveCamera,new THREE.PerspectiveCamera],this.clippingPlane=new THREE.Plane,this.copyCamera=function(t,e){e.matrixWorld.copy(t.matrixWorld),e.matrixWorldInverse.copy(t.matrixWorldInverse),e.projectionMatrix.copy(t.projectionMatrix),e.layers.mask=t.layers.mask};const r=this.el.sceneEl.renderer.state.setMaterial,i=function(t,e){r(t,!e)};this.unpatchWebGLState=function(t){t.setMaterial=r},this.patchWebGLState=function(t){t.setMaterial=i},this._mirrorPos=new THREE.Vector3,this._mirrorQuat=new THREE.Quaternion,this._cameraPos=new THREE.Vector3,this._cameraLPos=new THREE.Vector3,this._cameraRPos=new THREE.Vector3,this._normal=new THREE.Vector3,this._adjustMatrix=new THREE.Matrix4},setPortalId:function(t){this.portalId=t,this.surfaceMaterial.stencilRef=t},setInactive:function(){this.surfaceMaterial.stencilWrite=!1},setActive:function(){this.surfaceMaterial.stencilWrite=!0},update:function(){this.layers.disableAll(),this.data.layers.map((t=>this.layers.enable(+t)))},preRender:function(){},postRender:function(){},render:function(t,i,s){if(!this.insideFrustum)return;this.insideFrustum=!1;const n=t.xr.isPresenting?t.xr.getCamera():this.tempCamera;let a;const o=this.el.object3D.getWorldPosition(this._mirrorPos),l=this._normal.set(0,0,1);if(l.applyQuaternion(this.el.object3D.getWorldQuaternion(this._mirrorQuat)),t.xr.isPresenting){const t=n.cameras;this._cameraLPos.setFromMatrixPosition(t[0].matrixWorld),this._cameraRPos.setFromMatrixPosition(t[1].matrixWorld),a=this._cameraLPos.subVectors(o,this._cameraLPos).dot(l)<=0||this._cameraRPos.subVectors(o,this._cameraRPos).dot(l)<=0}else{a=s.getWorldPosition(this._cameraPos).subVectors(o,this._cameraPos).dot(l)<=0}if(!a)return;this.createClippingPlane(this.clippingPlane),this.onBeforeRender&&this.onBeforeRender(t,i,s,this);const c=this.createAdjustMatrix(this._adjustMatrix);if(t.xr.isPresenting){const t=n.cameras;this.copyCamera(n,this.tempCamera);for(let e=0;e<t.length;e++)this.copyCamera(t[e],this.tempCameras[e]),t[e].matrixWorld.premultiply(c),t[e].matrixWorldInverse.copy(t[e].matrixWorld).invert(),t[e].layers.mask=this.layers.mask;r(n,t[0],t[1]),e(t[0],this.clippingPlane),e(t[1],this.clippingPlane)}else n.near=s.near,n.far=s.far,n.projectionMatrix.copy(s.projectionMatrix),n.matrix.copy(s.matrixWorld).premultiply(c),n.matrix.decompose(n.position,n.quaternion,n.scale),n.matrixWorld.copy(n.matrix),n.matrixWorldInverse.copy(n.matrix).invert(),e(n,this.clippingPlane);const m=this.el.getObject3D("mesh");m.visible=!1,t.xr.cameraAutoUpdate=!1,this.preRender(t),t.state.buffers.stencil.setTest(!0),t.state.buffers.stencil.setFunc(THREE.EqualStencilFunc,this.portalId,255),t.state.buffers.stencil.setOp(THREE.KeepStencilOp,THREE.KeepStencilOp,THREE.KeepStencilOp),t.state.buffers.stencil.setLocked(!0),t.clearDepth();const p=n.layers.mask;n.layers.mask=this.layers.mask;const h=i.matrixWorldAutoUpdate;if(i.matrixWorldAutoUpdate=!1,t.render(i,this.tempCamera),i.matrixWorldAutoUpdate=h,n.layers.mask=p,t.state.buffers.stencil.setLocked(!1),this.postRender(t),t.xr.cameraAutoUpdate=!0,m.visible=!0,t.xr.isPresenting){const t=n.cameras;this.copyCamera(this.tempCamera,n);for(let e=0;e<t.length;e++)this.copyCamera(this.tempCameras[e],t[e])}this.onAfterRender&&this.onAfterRender(t,i,s,this)},remove:function(){this.el.sceneEl.systems.portal.unregisterPortal(this)}};AFRAME.registerComponent("mirror",{...t,createClippingPlane:function(t){const e=this.el.object3D.getWorldPosition(this._mirrorPos),r=this._normal.set(0,0,1);r.applyQuaternion(this.el.object3D.getWorldQuaternion(this._mirrorQuat));const i=-e.dot(r);return t.set(r,i)},createAdjustMatrix:function(t){const e=this.clippingPlane.normal,r=this.clippingPlane.constant;return t.set(1-2*e.x*e.x,-2*e.x*e.y,-2*e.x*e.z,-2*e.x*r,-2*e.x*e.y,1-2*e.y*e.y,-2*e.y*e.z,-2*e.y*r,-2*e.x*e.z,-2*e.y*e.z,1-2*e.z*e.z,-2*e.z*r,0,0,0,1)},preRender:function(t){this.patchWebGLState(t.state)},postRender:function(t){this.unpatchWebGLState(t.state)}}),AFRAME.registerComponent("portal",{...t,schema:{...t.schema,destination:{type:"selector"}},createClippingPlane:function(t){const e=this.data.destination.object3D.getWorldPosition(this._mirrorPos),r=this._normal.set(0,0,1);r.applyQuaternion(this.data.destination.object3D.getWorldQuaternion(this._mirrorQuat));const i=-e.dot(r);return t.set(r,i)},rotate180Matrix:(new THREE.Matrix4).makeRotationY(Math.PI),createAdjustMatrix:function(t){return t.copy(this.el.object3D.matrixWorld),t.invert().premultiply(this.rotate180Matrix).premultiply(this.data.destination.object3D.matrixWorld)}}),AFRAME.registerPrimitive("a-mirror",{defaultComponents:{geometry:{primitive:"plane"},mirror:{}},mappings:{layers:"mirror.layers"}}),AFRAME.registerPrimitive("a-portal",{defaultComponents:{geometry:{primitive:"plane"},portal:{}},mappings:{layers:"portal.layers",destination:"portal.destination"}});const e=function(){const t=new THREE.Vector4,e=new THREE.Plane,r=new THREE.Vector4;return function(i,s){e.copy(s).applyMatrix4(i.matrixWorldInverse);const n=t.set(e.normal.x,e.normal.y,e.normal.z,e.constant),a=i.projectionMatrix;r.x=(Math.sign(n.x)+a.elements[8])/a.elements[0],r.y=(Math.sign(n.y)+a.elements[9])/a.elements[5],r.z=-1,r.w=(1+a.elements[10])/a.elements[14],n.multiplyScalar(2/n.dot(r)),a.elements[2]=n.x,a.elements[6]=n.y,a.elements[10]=n.z+1+0,a.elements[14]=n.w}}(),r=function(){const t=new THREE.Vector3,e=new THREE.Vector3;return function(r,i,s){t.setFromMatrixPosition(i.matrixWorld),e.setFromMatrixPosition(s.matrixWorld);const n=t.distanceTo(e),a=i.projectionMatrix.elements,o=s.projectionMatrix.elements,l=a[14]/(a[10]-1),c=a[14]/(a[10]+1),m=(a[9]+1)/a[5],p=(a[9]-1)/a[5],h=(a[8]-1)/a[0],d=(o[8]+1)/o[0],u=l*h,f=l*d,E=n/(-h+d),x=E*-h;i.matrixWorld.decompose(r.position,r.quaternion,r.scale),r.translateX(x),r.translateZ(E),r.matrixWorld.compose(r.position,r.quaternion,r.scale),r.matrixWorldInverse.copy(r.matrixWorld).invert();const y=l+E,R=c+E,P=u-x,g=f+(n-x),M=m*c/R*y,W=p*c/R*y;r.projectionMatrix.makePerspective(P,g,M,W,y,R)}}();parseInt(AFRAME.THREE.REVISION)>=163&&document.addEventListener("render-target-loaded",(t=>{let e=t.target.getAttribute("renderer")??"";/stencil\s*:\s*true/g.test(e)||(console.warn('[aframe-mirror] Mirror component requires a stencil buffer, enabling it. Add `renderer="stencil: true"` to your <a-scene> to get rid of this warning.'),e+=";stencil:true"),t.target.setAttribute("renderer",e)}))}));
